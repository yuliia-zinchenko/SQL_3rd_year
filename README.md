
Ця лабораторна робота є розширенням початкової системи управління лікарнею, реалізованої на PostgreSQL. 

В рамках роботи було реалізовано гібридну систему, де структуровані транзакційні дані зберігаються в **PostgreSQL**, а гнучкі, напівструктуровані дані та кеш — у відповідних NoSQL СУБД: **MongoDB** та **Redis**.


## 1. Обґрунтування використання NoSQL у предметній області

Ддля винесення обрано медичні записи пацієнтів, а саме — результати обстежень та аналізів, адже результати аналізів мають різну структуру, та для отримання повної історії хвороби пацієнта в SQL необхідно виконати велику кількість `JOIN`-операцій. У документо-орієнтованій базі вся інформація про один візит може зберігатися в одному документі, що зводить отримання даних до однієї швидкої операції читання.

## 2. Реалізація в документо-орієнтованій СУБД (MongoDB)

На основі аргументів вище було обрано **MongoDB** для зберігання детальних результатів обстежень.

*   **Модель даних:** Було створено колекцію `medical_observations`. Кожен документ в ній містить посилання на відповідний запис в SQL-таблиці `Medical_Records` (`record_id`), а також гнучку структуру для зберігання результатів у вкладеному об'єкті `results`.
    ```json
    {
      "record_id": 1, 
      "observation_date": ISODate("..."),
      "type": "blood_analysis",
      "results": {
        "hemoglobin": { "value": 140, "unit": "g/L" },
        "leukocytes": { "value": 6.5, "unit": "10^9/L" }
      },
      "doctor_notes": "Patient is healthy."
    }
    ```
*   **Реалізація:** В Python було створено `ObservationRepository`, який за допомогою бібліотеки `pymongo` інкапсулює логіку роботи з MongoDB (додавання та пошук документів).

## 3. Аналогічна реалізація в SQL (PostgreSQL)

Для коректного порівняння продуктивності аналогічний функціонал було реалізовано в PostgreSQL з використанням сучасного підходу — поля типу **`JSONB`**.

*   **Модель даних:** До існуючої таблиці `Medical_Records` було додано нове поле `observations` типу `JSONB`. Цей тип даних дозволяє ефективно зберігати та індексувати JSON-документи безпосередньо в реляційній базі.
    ```sql
    ALTER TABLE Medical_Records ADD COLUMN observations JSONB;
    ```
*   **Реалізація:** Було створено `SqlObservationRepository`, який оновлює та читає дані з цього `JSONB`-поля.

## 4. Тестування та аналіз продуктивності

Тестування проводилося для двох ключових операцій: **читання** та **запис**.

#### Методологія

Було згенеровано 10,000 записів в обидві бази даних (PostgreSQL та MongoDB) для імітації реального навантаження. Для кожного тесту виконувалося 1,000 випадкових операцій читання або запису, такий обсяг даних та кількість операцій є достатніми для виявлення статистично значущих відмінностей у продуктивності та мінімізації впливу випадкових коливань.

**Результати тесту на читання:**

| Операція | PostgreSQL (Local) | MongoDB (Local) | Перевага |
| :--- | :--- | :--- | :--- |
| **Читання** | **0.4066 ms** | 1.0882 ms | PostgreSQL в ~2.7 разів швидший |

**Аналіз:** Навіть в однакових умовах PostgreSQL виявився швидшим. Причини:

 Бінарний формат зберігання в PostgreSQL є менш "багатослівним", ніж BSON в MongoDB.
 Процес десеріалізації BSON в словник Python (`pymongo`) може додавати невеликі, але вимірювані накладні витрати.

**Результати тесту на запис:**

| Операція | PostgreSQL (Local) | MongoDB (Local) | Перевага |
| :--- | :--- | :--- | :--- |
| **Запис** | **0.4491 ms** | 0.9405 ms | PostgreSQL в ~2.1 разів швидший |

**Аналіз:** Цей результат пояснюється стратегією виконання операцій у тестовому скрипті:
Транзакційна модель: У тесті для PostgreSQL виконувалося 1000 `UPDATE` в рамках однієї великої транзакції з єдиним `commit()` в кінці. Це дуже ефективна "оптова" операція.
Гарантії запису: Кожна операція `update_one` в MongoDB є, по суті, окремою мікро-транзакцією з підтвердженням від сервера, що створює більші накладні витрати на кожну ітерацію.

**Загальний висновок по тестуванню:** Для простих CRUD-операцій на індексованих полях, високо оптимізована реляційна СУБД, як PostgreSQL, може демонструвати кращу продуктивність, ніж NoSQL аналоги. Сила MongoDB полягає в гнучкості схеми та горизонтальній масштабованості, що не було предметом цього тесту.

## 5. Реалізація в СУБД іншого типу (Redis)

Для демонстрації роботи з NoSQL базою іншого типу було обрано **Redis (ключ-значення)**.

 **Сценарій використання:** Кешування даних, що часто запитуються, але рідко змінюються. Ідеальним кандидатом став розклад прийому лікаря на поточний день. Реалізований патерн: "Cache-Aside".
   - Програма спочатку перевіряє наявність даних у кеші Redis.
   - "Влучання в кеш" (Cache Hit): Якщо дані є, вони миттєво повертаються, без звернення до основної бази.
    -"Промах кешу" (Cache Miss): Якщо даних немає, програма виконує "повільний" запит до PostgreSQL.
    - Отримані дані зберігаються в Redis з обмеженим часом життя (TTL, встановлено на 1 годину) для використання у наступних запитах.

*   **Результати демонстрації:**
    *   **Перший запит (промах кешу):** час виконання ~2.5 секунди (з імітацією затримки).
    *   **Другий запит (влучання в кеш):** час виконання **~0.001 секунди**.

**Висновок:** Демонстрація наочно показала **прискорення у ~2500 разів** для повторних запитів та значне зменшення навантаження на основну базу даних PostgreSQL, що підтверджує ефективність Redis для завдань кешування.

