# Лабораторна робота: Система управління лікарнею

Проєкт є реалізацією серверної частини системи управління лікарнею. Робота виконана з використанням Python для бізнес-логіки та PostgreSQL як реляційної СУБД.

## Технології та інструменти

*   **Мова програмування:** Python 3.x
*   **СУБД:** PostgreSQL
*   **Бібліотеки Python:** `psycopg2-binary`, `python-dotenv`
*   **Архітектурні патерни:** Repository, Unit of Work
*   **Схема:** [diagram.io](https://dbdiagram.io/d/69061e0f6735e11170c751b7)

## Структура проєкту

```
LAB_1/
├── .env.example          # Приклад файлу конфігурації
├── .gitignore            # Файл для ігнорування непотрібних файлів Git
├── hospital/             # Основний пакет з кодом програми
│   ├── main.py           # Точка входу, демонстрація роботи
│   ├── database/
│   │   ├── connection.py # Логіка підключення до БД
│   │   ├── schema.sql    # DDL-скрипт для створення структури БД
│   │   └── data.sql      # DML-скрипт для заповнення початковими даними
│   ├── repositories/
│   │   ├── base_repository.py
│   │   ├── patient_repository.py
│   │   └── appointment_repository.py
│   └── unit_of_work/
│       └── unit_of_work.py
├── requirements.txt      # Список залежностей Python
└── README.md             # Цей файл
```

---

## Інструкція по встановленню та запуску

Щоб розгорнути та запустити проєкт, виконайте наступні кроки.

### 1. Передумови

*   Встановлений **Python** (версія 3.8 або вище).
*   Встановлений та запущений сервер **PostgreSQL**.

### 2. Клонування репозиторію

```bash
git clone https://github.com/yuliia-zinchenko/SQL_3rd_year
```

### 3. Налаштування Python середовища

Створіть та активуйте віртуальне середовище і встановіть необхідні бібліотеки.

```bash
# Створення віртуального середовища
python -m venv venv

# Активація (Windows)
venv\Scripts\activate

# Активація (macOS/Linux)
source venv/bin/activate

# Встановлення залежностей
pip install -r requirements.txt
```

### 4. Налаштування бази даних

1.  **Створіть базу даних та користувача** в PostgreSQL.
    ```sql
    -- Приклад команд в psql
    CREATE USER myuser WITH PASSWORD 'mypassword';
    CREATE DATABASE hospital_db OWNER myuser;
    ```

2.  **Налаштуйте файл конфігурації.** Скопіюйте `.env.example` та перейменуйте копію на `.env`. Відкрийте `.env` та вкажіть ваші реальні дані для підключення до БД.
    ```env
    DB_HOST=localhost
    DB_NAME=hospital_db
    DB_USER=myuser
    DB_PASSWORD=mypassword
    ```

3.  **Розгорніть структуру та дані.** Виконайте надані SQL-скрипти за допомогою утиліти `psql`. **Порядок виконання є важливим.**

    *   Спочатку створюємо структуру (таблиці, функції, view):
    ```bash
    psql --host=localhost --username=myuser --dbname=hospital_db --file=hospital/database/schema.sql
    ```
    *   Потім завантажуємо початкові дані (лікарі, відділення):
    ```bash
    psql --host=localhost --username=myuser --dbname=hospital_db --file=hospital/database/data.sql
    ```

### 5. Запуск програми

Після успішного налаштування, запустіть головний скрипт з кореневої папки проєкту.

```bash
python -m hospital.main
```

У консолі з'явиться інтерактивне меню, де можна вибрати дії для демонстрації функціоналу.

---

## Детальний опис виконаної роботи

### 1-2. Схема бази даних

Спроєктовано реляційну схему даних, що складається з **19 сутностей** для покриття основних процесів лікарні: управління персоналом, пацієнтами, записами на прийом, медичними картками, рахунками тощо. Усі зв'язки, первинні та зовнішні ключі визначені у файлі `hospital/database/schema.sql`.

### 3. Підтримка "Soft Delete" та аудиту

*   **"М'яке видалення" (Soft Delete):** Деякі ключові сутності не видаляються з бази даних фізично, а позначаються як видалені. Це реалізовано за допомогою булевого поля `is_deleted`. Такий підхід використано для таблиць:
    *   `Patients`
    *   `Appointments`
    *   `Billings`

*   **Аудит змін:** Для відстеження історії змін у важливих таблицях додано поля:
    *   `created_at`: фіксує час створення запису (за замовчуванням `now()`).
    *   `updated_at`: фіксує час останньої зміни (оновлюється автоматично за допомогою тригера).
    *   `updated_by`: зберігає ID користувача, який вніс останні зміни.
    Цей механізм реалізовано в таблицях: `Staff`, `Patients`, `Appointments`, `Medical_Records`, `Billings`.

### 4. Реалізація в СУБД PostgreSQL

Вся розроблена схема даних, включаючи таблиці, зв'язки та обмеження, була успішно реалізована в СУБД PostgreSQL. Повний DDL-скрипт знаходиться у файлі `hospital/database/schema.sql`.

### 5. Використання об'єктів БД (10 об'єктів)

Для реалізації бізнес-логіки на рівні бази даних було створено 10 об'єктів:

*   **Тригерна функція (1):**
    *   `update_timestamp()`: Універсальна функція, що встановлює поточний час у поле `updated_at`. Використовується усіма тригерами на оновлення.

*   **Тригери (4):**
    *   `trigger_patients_update` на таблиці `Patients`.
    *   `trigger_staff_update` на таблиці `Staff`.
    *   `trigger_appointments_update` на таблиці `Appointments`.
    *   `trigger_medical_records_update` на таблиці `Medical_Records`.
    *   **Призначення:** Автоматично оновлюють поле `updated_at` при будь-якій зміні рядка.

*   **Збережені процедури (2):**
    *   `sp_soft_delete_patient(p_patient_id, p_user_id)`: Реалізує логіку "м'якого видалення" для пацієнта. Встановлює `is_deleted = true` та оновлює поля аудиту.
    *   `sp_soft_delete_appointment(p_appointment_id, p_user_id)`: Аналогічна процедура для "м'якого видалення" запису на прийом.

*   **Користувацькі функції (2):**
    *   `fn_get_active_patients_count()`: Повертає загальну кількість активних (не видалених) пацієнтів.
    *   `fn_get_patient_outstanding_balance(p_patient_id)`: Розраховує та повертає загальну суму неоплачених рахунків для конкретного пацієнта.

*   **Розріз даних (View) (1):**
    *   `v_active_appointments`: Спрощує отримання даних про активні записи на прийом, об'єднуючи інформацію з таблиць `Appointments`, `Patients`, `Staff` та `Doctors`. Це дозволяє приховати складність `JOIN`-запитів від програмного коду.

### 6. Створення індексів

Для оптимізації продуктивності запитів було створено індекси двох різних типів:

1.  **B-Tree індекс (стандартний):** Для полів, що часто використовуються у `WHERE` умовах та для сортування.
    *   `idx_patients_last_name` на полі `last_name` в таблиці `Patients`.
    *   `idx_appointments_date` на полі `appointment_date` в таблиці `Appointments`.

2.  **Частковий індекс (Partial Index):** Для індексації тільки частини рядків таблиці, що задовольняють певній умові. Це зменшує розмір індексу та прискорює операції запису.
    *   `idx_active_appointments`: Індексує тільки активні записи (`WHERE is_deleted = false`).
    *   `idx_unpaid_billings`: Індексує тільки неоплачені рахунки (`WHERE status = 'unpaid' AND is_deleted = false`).

### 7. Робота з БД з коду (Repository + Unit of Work)

Взаємодія з базою даних з Python-коду реалізована за допомогою комбінації архітектурних патернів **Repository** та **Unit of Work**.

*   **Патерн Repository:** Інкапсулює логіку доступу до даних для кожної сутності. Наприклад, `PatientRepository` містить методи для додавання, отримання та видалення пацієнтів. Це дозволяє ізолювати SQL-запити від бізнес-логіки.

*   **Патерн Unit of Work:** Координує роботу кількох репозиторіїв в рамках однієї бізнес-транзакції. Клас `UnitOfWork` керує з'єднанням з БД та забезпечує атомарність операцій: або всі зміни успішно зберігаються (`commit`), або всі вони відкочуються у випадку помилки (`rollback`).

**Приклад реалізації:** Функція `register_patient_and_schedule_appointment` у `main.py` демонструє, як `Unit of Work` гарантує, що новий пацієнт і запис на прийом для нього будуть створені разом як єдина неподільна операція.
